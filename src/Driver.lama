-- Driver: a top-level compiler utility

import List;
import Ref;
import Array;
import Fun;
import Ostap;
import Parser;
import Matcher;
import Lexer;
<<<<<<< HEAD
import Expr;
=======
import Stmt;
>>>>>>> A05-control-flow-sm-x86
import SM;
import X86;
import Manifest;

-- Parses a command-line arguments, represented as a list, and
-- returns an environment. The environment's interface is
-- defined in the unit Manifest
fun parseArgs (args) {
  local mode   = ref (Comp),
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> A05-control-flow-sm-x86
        infile = ref ({}),
        smDump = ref (false);

  fun setDump (m) {
    case m of
      SM -> smDump ::= true
    esac
  }
  
<<<<<<< HEAD
=======
=======
        infile = ref ({});

>>>>>>> A04-control-flow-int
>>>>>>> A05-control-flow-sm-x86
  fun setMode (m) {
    case deref (mode) of
      Comp -> mode ::= m
    | _    -> failure ("mode already set: %s\n", deref (mode).string)
    esac
  }

  fun setInFile (fn) {
    case deref (infile) of
      #unboxed -> infile ::= fn
    | _        -> failure ("omitting ""%s"", input file name already set to ""%s""\n", fn, deref (infile))
    esac
  }
  
  fix (fun (rec) {
         fun (args) {
            case args of
              {}    -> skip
            | h : t ->
               case h of
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> A05-control-flow-sm-x86
                 "-i"  -> setMode (Int)
               | "-s"  -> setMode (SM)
               | "-ds" -> setDump (SM)
               | fn    -> setInFile (fn)
<<<<<<< HEAD
=======
=======
                 "-i" -> setMode (Int)
               | "-s" -> setMode (SM)
               | fn   -> setInFile (fn)
>>>>>>> A04-control-flow-int
>>>>>>> A05-control-flow-sm-x86
               esac;
               rec (t)
            esac
         }
      })(args);

<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> A05-control-flow-sm-x86
  [fun () {deref (mode)},
   fun () {case deref(infile) of #unboxed -> failure ("input file name not set\n") | fn -> fn esac},
   fun () {deref (smDump)}
  ]        
}

-- Utility function to peeping to SM code
fun peepSM (args, smCode) {
  dumpSM (args, lazy (showSM (smCode)));
  smCode
}

<<<<<<< HEAD
=======
=======

  [fun () {deref (mode)},
   fun () {case deref(infile) of #unboxed -> failure ("input file name not set\n") | fn -> fn esac}
  ]        
}

>>>>>>> A04-control-flow-int
>>>>>>> A05-control-flow-sm-x86
local args = parseArgs (arrayList (sysargs).tl);

-- The main part: parses input file, invokes interpreter/stack machine interpreter/x86
-- code generator
case parseString (parse |> bypass (end), fread (args.getInFile)) of
  Succ (program) ->
    case args.getMode of
<<<<<<< HEAD
      Comp -> compileX86 (args, peepSM (args, compileSM (program)))
=======
<<<<<<< HEAD
      Comp -> compileX86 (args, peepSM (args, compileSM (program)))
=======
      Comp -> compileX86 (args, compileSM (program))
>>>>>>> A04-control-flow-int
>>>>>>> A05-control-flow-sm-x86
    | mode ->
       local input =
          reverse (fix (fun (f) {
                          fun (acc) {
                            case readLine () of
                              #unboxed -> acc
                            | arg      -> f (stringInt (arg) : acc) esac
                          }
                        }) ({}));
<<<<<<< HEAD

       iter (fun (x) {printf ("%d\n", x)},
             case mode of
               Int -> evalExpr (input, program)
             | SM  -> evalSM   (input, peepSM (args, compileSM (program)))
             esac) 
=======
          
       iter (fun (x) {printf ("%d\n", x)},
             case mode of
               Int -> evalStmt (input, program)
<<<<<<< HEAD
             | SM  -> evalSM   (input, peepSM (args, compileSM (program)))
=======
             | SM  -> evalSM (input, compileSM (program))
>>>>>>> A04-control-flow-int
             esac)
>>>>>>> A05-control-flow-sm-x86
    esac
| x@Fail (err, line, col) ->   
   failure ("%s at %d:%d\n", err.hd, line, col)
esac
